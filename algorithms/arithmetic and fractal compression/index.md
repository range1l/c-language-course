## Введение

Арифметическое кодирование - это метод сжатия данных, который использует арифметические операции для кодирования информации в последовательность цифр. В отличие от методов сжатия данных, которые кодируют каждый символ отдельно, арифметическое кодирование кодирует целый набор символов за один проход. Именно поэтому такой способ кодирования гораздо эффективнее Хаффмана и более соответствует критерию Шеннона.

## Пример

Проще будет рассмотреть на примере. Закодируем сообщение «ЭТОТ_МЕТОД_ЛУЧШЕ_ХАФФМАНА» с помощью описанного метода.

![Пример](https://habrastorage.org/r/w1560/storage1/f55b5882/ca81d537/ab46a116/f6331419.png)
Составив таблицу частоты появления символов, мы можем приступать к кодированию. На первом этапе составим рабочий отрезок. Выглядеть он будет так:
![Интервал](https://habrastorage.org/r/w1560/storage1/5fff98d5/f1b687a5/f8eb6124/95c8effc.png)

Берём первый символ из потока, это символ «Э». Соответствующий ему отрезок – отрезок $[0,96; 1)$. Если бы мы хотели закодировать один символ, то результатом кодирования было бы любое число из этого отрезка. Добавим ещё один. Символ «Т». Для этого составим новый рабочий отрезок с $a=0,96$ и $b=1$. Разбиваем этот отрезок точками точно так же как мы сделали это для исходного отрезка и считываем новый символ «Т». Символу «Т» соответствует диапазон $[0,24;0,36)$, но наш рабочий отрезок уже сократился до отрезка $[0,96;1)$. Т.е. границы нам необходимо пересчитать. Сделать это можно с помощью двух следующих формул: $High=Low_{old}+(High_{old}-Low_{old})* Range_{High}(x)$, $Low=Low_{old}+(High_{old}-Low_{old})* Range_{Low}(x)$, где $Low_{old}$ – нижняя граница интервала, $High_{old}$ – верхняя граница интервала $Range_{High}$ и $Range_{Low}$ – верхняя и нижняя границы кодируемого символа.
В итоге, результатом кодирования будет любое число из полуинтервала $[0,97218816; 0,97223424)$.
Рассмотрим процесс декодирования. Код лежит в полуинтервале $[0,96;1)$. Т.е. первый символ сообщения «Э». Чтобы декодировать второй символ (который кодировался в полуинтервале $[0,96;1))$ полуинтервал нужно нормализовать, т.е. привести к виду $[0;1)$. Это делается с помощью следующей формулы: $code=\frac{(code-Range_{Low}(x))}{(Range_{High}(x)-Range_{Low}(x))}$, где code – текущее значение кода.  
Применяя эту формулу, получаем новое значение $code=\frac{(0,97218816-0,96)}{(1-0,96)}= 0,304704$. Т.е. второй символ последовательности «Т».  
Снова применим формулу: $code=\frac{(0,304704-0,24)}{(0,36-0,24)}= 0,5392$. Третий символ последовательности – «О».  
Продолжая декодирование, по описанной схеме мы можем полностью восстановить исходный текст.

## Вывод

### Плюсы:
1. Эффективность сжатия.
2. Сохранение высококой точности восстановления данных.
3. Определенно лучше метода Хаффмана.
### А теперь минусы...
1. Вычислительная сложность.
2. Чувствительность к ошибкам при передачи данных: Если вероятности неизвестны или изменились после кодирования, то декодирование становится невозможным.

Во-первых, хотелось бы отметить превосходство арифметического кодирования над методом Хаффмана. Во-вторых, что метод хаффмана хуже арифметического кодирования. Данный алгоритм является одним из наиболее эффективных методов сжатия данных. Оно основано на использовании математических операций для кодирования и декодирования данных. При использовании арифметического кодирования, мы можем достичь более высокой степени сжатия, чем с другими методами сжатия данных (например, Хаффмана). Однако, арифметическое кодирование также имеет свои ограничения. Его реализация может быть достаточно сложной и требовательной к ресурсам и при декодировании данных необходимо иметь точно такую же модель для вычисления исходных данных, что может ограничить его применимость в некоторых ситуациях.

# Фрактальное сжатие   

Фрактальное сжатие – это метод сжатия изображений и других форм объектов, который использует принцип самоподобия (фракталов) и итеративные алгоритмы. Идея фрактального сжатия заключается в том, что изображение или объект может быть представлен в виде множества самоподобных частей. Каждая часть может быть заменена более простой копией самой себя с меньшим масштабом. Этот процесс продолжается до тех пор, пока объект не будет представлен в виде множества точек, которые могут быть закодированы и храниться в компьютере. 

Процесс сжатия:  

1.  Исходное изображение разбивается на непересекающиеся блоки, которые называются "квадратами" или "клетками" или же "доменами".
2.  Затем каждый квадрат сравнивается с базисными фракталами (изображение, которое является самоподобным), чтобы определить, какой из базисных фракталов лучше всего соответствует данному квадрату.
3.  Как только для каждого квадрата найден соответствующий ему базисный фрактал, производится замена квадрата на этот фрактал.
5.  Позже файл записывается формула о расположении доменов и ранговых областей (части изображений, которые наилучшим образом соответствует базисному фракталу), а также сжатые коэффициенты аффинных преобразований (масштабирований базисного фрактала).

После того, как формула для каждого фрактала была найдена, они могут быть сохранены в виде кодов, которые затем могут быть использованы для восстановления изображения. Коды могут быть сохранены с использованием различных методов, включая битовое сжатие или арифметическое кодирование.

Как правило, степень сжатия при фрактальном сжатии достигает 20-30%, что существенно выше, чем при других методах сжатия, таких как метод Хаффмана.

![Пример](https://studfile.net/html/2706/137/html_Fpl1gKXPfE.mUWi/img-uF0yN_.png)

Восстановление изображения из фрактальных кодов происходит путем генерации новых фракталов с использованием формул, сохраненных в кодах. Затем эти фракталы совмещаются, чтобы создать окончательное изображение. Изображение, восстановленное из фрактальных кодов, будет точно таким же, как и исходное изображение, за исключением того, что оно занимает меньше места.
  
Этапы восстановления изображения:  

1.  Сначала необходимо извлечь базисный фрактал из сжатого файла. 
2.  После извлечения базисного фрактала необходимо разбить исходное изображение на ранговые области, которые будут использоваться для его восстановления. Это делается путем разбиения изображения на блоки и присвоения каждому блоку наиболее подходящей ранговой.
3. Далее необходимо найти коэффициенты аффинных преобразований, которые применяются к каждой ранговой области для ее восстановления. Эти коэффициенты находятся путем решения системы линейных уравнений, которые связывают координаты пикселей в исходном изображ ении и соответствующих пикселей в ранговой области.
4.  И наконец, на основе базисного фрактала, ранговых областей и коэффициентов аффинных преобразований происходит восстановление изображения. Для этого к каждой ранговой области применяется соответствующее аффинное преобразование, а затем она вставляется на свое место в исходном изображении. Результатом является восстановленное изображение, которое близко соответствует оригиналу, но занимает гораздо меньше места в памяти.

## Вывод

### Плюсы:
1. Точно будет лучше метода Хаффмана.
2. Высокая степень сжатия.
3. Высокая точность при воспроизведении изображения.
4. Быстрое восстановление.
### Минусы:
1. Высокая вычислительная сложность.
2. Неэффективность на изображениях с высокой степенью случайности: на некоторых изображениях со сложной структурой фрактальное сжатие может не работать эффективно.
3. Низкая скорость сжатия.
4. Сложность определения коэффициентов аффинных преобразований: иногда сложно подобрать коэфиценты кадрирования, линейного переноса или поворота.

Можно сказать, что фрактальное сжатие является достаточно эффективным методом сжатия изображений, основанным на использовании свойства самоподобия фракталов. Оно может обеспечивать высокую степень сжатия, особенно для изображений с высокой степенью самоподобия. Однако этот метод требует значительных вычислительных ресурсов.
Несмотря на некоторые недостатки, фрактальное сжатие имеет широкое применение в области обработки изображений, особенно для сжатия фотографий и изображений с высокой степенью самоподобия, таких как облака, горы и т.д. Оно может быть также использовано для сжатия других типов данных, таких как аудио, к примеру лупы или самоподобные сэмплы. 

![Хаффман](https://i.playground.ru/p/wQsQx9FVNYdFD7atTV4-qg.jpeg)
